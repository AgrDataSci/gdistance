<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>gdistance: Distances and Routes on Geographical Grids • gdistance</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="gdistance: Distances and Routes on Geographical Grids">
<meta property="og:description" content="">
<meta property="og:image" content="/logo.png">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">gdistance</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.3.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Overview.html">gdistance: Distances and Routes on Geographical Grids</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="Overview_files/header-attrs-2.1/header-attrs.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>gdistance: Distances and Routes on Geographical Grids</h1>
                        <h4 class="author">Jacob van Etten</h4>
            <address class="author_afil">
      The Alliance of Bioversity International and CIAT, Rome, Italy<br><div class="hidden name"><code>Overview.Rmd</code></div>

    </address>
</div>

    
    
<div id="summary" class="section level1">
<h1 class="hasAnchor">
<a href="#summary" class="anchor"></a>Summary</h1>
<p>The <code>R</code> package <strong>gdistance</strong> provides classes and functions to calculate various distance measures and routes in heterogeneous geographic spaces represented as grids. Least-cost distances as well as more complex distances based on (constrained) random walks can be calculated. Also the corresponding routes or probabilities of passing each cell can be determined. The package implements classes to store the data about the probability or cost of transitioning from one cell to another on a grid in a memory-efficient sparse format. These classes make it possible to manipulate the values of cell-to-cell movement directly, which offers flexibility and the possibility to use asymmetric values. The novel distances implemented in the package are used in geographical genetics (applying circuit theory), but may also have applications in other fields of geospatial analysis.</p>
<p>This vignette was published as an article in the Journal of Statistical Software:</p>
<blockquote>
<p>van Etten, Jacob. <span class="citation">(2017)</span>. “R Package gdistance: Distances and Routes on Geographical Grids.” <strong>Journal of Statistical Software</strong> 76 (13): 1–21. <a href="https://doi.org/10.18637/jss.v076.i13" class="uri">https://doi.org/10.18637/jss.v076.i13</a>.</p>
</blockquote>
</div>
<div id="introduction-the-crow-the-wolf-and-the-drunkard" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction-the-crow-the-wolf-and-the-drunkard" class="anchor"></a>Introduction: the crow, the wolf, and the drunkard</h1>
<p>This vignette describes gdistance, a package written for use in the <code>R</code> environment <span class="citation">(R Core Team 2016)</span>. It provides functionality to calculate various distance measures and routes in heterogeneous geographic spaces represented as grids. Distance is fundamental to geospatial analysis <span class="citation">(Tobler 1970)</span>. It is closely related to the concept of route. For example, take the great-circle distance, the most commonly used geographic distance measure. This distance represents the shortest line between two points, taking into account the curvature of the earth. Implicit in this distance measure is a route. The great-circle distance could be conceived of as the distance measured along a route of a very efficient traveller who knows where to go and has no obstacles to deal with. In common language, this is referred to as distance `as the crow flies’.</p>
<p>Other distance measures also imply a route across geographic space. The least-cost distance is implemented in most GIS software and mimics route finding ‘as the wolf runs’, taking into account obstacles and the local `friction’ of the landscape. Since least-cost distance is affected by the environment, grid-based calculations are necessary. Other grid-based distances have been developed based on the random walk or drunkard’s walk, in which route-finding is a stochastic process.</p>
<p>Package <strong>gdistance</strong> was designed to determine such grid-based distances and routes and to be used in combination with other packages available within R. The <strong>gdistance</strong> package is comparable to other software such as ArcGIS Spatial Analyst <span class="citation">(McCoy and Johnston 2002)</span>, GRASS GIS <span class="citation">( Development Team 2017)</span>, and CircuitScape <span class="citation">(McRae et al. 2008)</span>. The gdistance package also contains specific functionality for geographical genetic analyses, not found in other software yet. The package implements measures to model dispersal histories first presented by <span class="citation">(van Etten and Hijmans 2010)</span>.</p>
</div>
<div id="theory" class="section level1">
<h1 class="hasAnchor">
<a href="#theory" class="anchor"></a>Theory</h1>
<p>In <strong>gdistance</strong> calculations are done in various steps. This can be confusing at first for those who are used to distance and route calculations in GIS software, which are usually done in a single step. However, an important goal of <strong>gdistance</strong> is to make the calculations of distances and routes more flexible, which also makes the package more complicated to use. Users, therefore, need to have a basic understanding of the theory behind distance and route calculations.</p>
<p>Calculations of distances and routes start with raster data. In geospatial analysis, rasters are rectangular, regular grids that represent continuous data over geographical space. Cells are arranged in rows and columns and each holds a value. A raster is accompanied by metadata that indicate the resolution, extent and other properties.</p>
<p>Distance and route calculations on rasters rely on graph theory. So as a first step, rasters are converted into graphs by connecting cell centres to each other, which become the nodes in the graph. This can be done in various ways, but only three neighbourhood graphs are commonly implemented in distance calculation software (Figure 1).</p>
<ul>
<li>Cells can be connected orthogonally to their four immediate neighbours, the von Neumann neighbourhood.</li>
<li>Cells can be connected with their eight orthogonal and diagonal nearest neighbours, the Moore neighbourhood. The resulting graph is called the king’s graph, because it reflects all the legal movements of the king in chess. This is the most common and often only way to connect grids in GIS software.</li>
<li>Connecting the cell centres in 16 directions combines king’s and knight’s moves. The function r.cost in the software GRASS <span class="citation">( Development Team 2017)</span> has this as an option, which inspired its implementation in <strong>gdistance</strong>. The section on distance transforms in <span class="citation">(de Smith, Goodchild, and Longley 2009)</span> also discusses 16-cell neighbourhoods. Connecting in 16 directions may increase the accuracy of the calculations.</li>
</ul>
<div class="figure" style="text-align: center">
<img src="Overview_files/figure-html/fig0-1.png" alt="Fig.1 : Three commonly used ways to generate neighbour graphs for distance calculations." width="700"><p class="caption">
Fig.1 : Three commonly used ways to generate neighbour graphs for distance calculations.
</p>
</div>
<p>When the raster is converted into a graph, weights are given to each edge (connections between nodes). These weights correspond to different concepts. In most GIS software, distance analyses are done with calculations using cost, friction or resistance values. In graph theory, weights can also correspond to conductance (1/resistance), which is equivalent to permeability (a term used in landscape ecology). The weights can also represent probabilities of transition.</p>
<p>Graphs are mathematically represented as matrices to do calculations. These can include transition probability matrices, adjacency matrices, resistance/conductance matrices, Laplacian matrices, among others. In <strong>gdistance</strong>, we refer collectively to these matrices to represent graphs as `transition matrices’. These transition matrices are the central object in the package; all distance calculations need one or more transition matrices as an input.</p>
<p>In <strong>gdistance</strong>, conductance rather than resistance values are expected in the transition matrix. An important advantage of using conductance is that it makes it possible to store values in computer memory very efficiently. Conductance matrices usually contain mainly zeros, because cells are connected only with adjacent cells, and the conductance for direct connections between remote cells is zero. This makes conductance matrices suitable to store in the memory-efficient sparse matrix format. Sparse matrices do not store zero values explicitly in computer memory; they just store the non-zero values and their respective row and column indices and assume that the other values are zero. Sparse matrices do not work for resistance matrices, however, as resistance is infinite (<span class="math inline">\(\infty\)</span>) between unconnected cells.</p>
<p>The calculation of the edge weights or conductance values is usually based on the values of the pair of grid cells to be connected. These cell values represent a property of the landscape. For instance, from a grid with altitude values, a value for the ease of walking can be calculated for each transition between cells. In <strong>gdistance</strong>, users define a function <span class="math inline">\(f(i,j)\)</span> to calculate the transition value for each pair of adjacent cells i and j.</p>
<p>With this approach, it is possible to create asymmetric matrices, in which the conductance from cell i to adjacent cell j is not always the same as the conductance from j back to i. This is relevant, among other things, for modelling travel in hilly terrain, as shown in Example 1 below. On the same slope, a downslope traveler experiences less friction than an upslope traveler. In this case, the function to calculate conductance values is non-commutative: <span class="math inline">\(f(i,j) \neq f(j,i)\)</span>.</p>
<p>A problem that arises in grid-based modelling is the choice of weights that should be given to diagonal edges in proportion to orthogonal ones. For least-cost path distance and routes, this is fairly straightforward: weights are given in proportion to the distances between the cell centres. In a grid in which the orthogonal edges have a length of 1, the diagonal edges are <span class="math inline">\(\sqrt[]{2}\)</span> long. <span class="citation">(McRae 2006)</span> applies this same idea to random walks. However, as <span class="citation">(Birch 2006)</span> explains, for random walks this is generally not the best discrete approximation of the dispersal process in continuous space. Different orthogonal and diagonal weights could be considered based on his analytical results.</p>
<p>For random walks on longitude-latitude grids, there is an additional consideration to be made. Considering the eight neighbouring cells in a Moore’s neighbourhood, the three cells that are located nearer to the equator are larger in area than the three cells that are closer to the nearest pole, as the meridians converge when moving from the equator to either pole. So the cells closer to the poles should have a slightly lower probability of being reached during a random walk from the central cell. More theoretical work is needed to investigate possible solutions to this problem. For projected grids and small areas, we can safely ignore the surface distortion.</p>
<p>When the transition matrix has been constructed, different algorithms to calculate distances and routes are applied.</p>
<ul>
<li>The least-cost distance mimics route finding ‘as the wolf runs’, taking into account obstacles and the local ‘friction’ of the landscape. In <strong>gdistance</strong> the least-cost path between two cells on the grid and the associated distance is obtained with Dijkstra’s algorithm <span class="citation">(Dijkstra 1959)</span>.</li>
<li>A second type of route-finding is the random walk, which has no predetermined destination (a ‘drunkard’s walk’). Commute distance represents the random walk commute time, e.g., the average number of edges traversed during a random walk from an starting point on the graph to a destination point and back again to the starting point <span class="citation">(Chandra et al. 1996)</span>. Resistance distance reflects the average travel cost during this walk <span class="citation">(McRae 2006)</span>. When taken on the same graph these two measures differ only in their scaling <span class="citation">(Kivimäki, Shimbo, and Saerens 2014)</span>. Commute and resistance distances are calculated using the analogy with an electrical circuit see <span class="citation">(Doyle and Snell 1984)</span> for an introduction. The algorithm that <strong>gdistance</strong> uses to calculate commute distances was developed by <span class="citation">(Fouss et al. 2007)</span>.</li>
<li>A third type of route-finding is by randomised shortest paths, which are an intermediate form between shortest paths and Brownian random walks, introduced by <span class="citation">(Saerens et al. 2009)</span>. By setting a parameter, <span class="math inline">\(\theta\)</span> (theta), in the randomised shortest paths calculation, distances and routes can be made more randomised. A lower value of <span class="math inline">\(\theta\)</span> means that walkers explore more around the shortest path. When <span class="math inline">\(\theta\)</span> approaches zero, the randomised shortest paths approach a random walk. <span class="citation">(van Etten and Hijmans 2010)</span> applied randomised shortest paths in geospatial analysis (and see Example 2 below).</li>
</ul>
</div>
<div id="raster-basics" class="section level1">
<h1 class="hasAnchor">
<a href="#raster-basics" class="anchor"></a>Raster basics</h1>
<p>Analyses in <strong>gdistance</strong> start with one or more rasters. For this, it relies on another <code>R</code> package, <strong>raster</strong> <span class="citation">(Hijmans and van Etten 2016)</span>. The <strong>raster</strong> package provides comprehensive geographical grid functionality. Here, we briefly discuss this package, referring the reader to the documentation of <strong>raster</strong> itself for more information. The following code shows how to create a raster object.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span>(<span class="st">"gdistance"</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="dv">123</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a>r &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="dt">ncol=</span><span class="dv">3</span>,<span class="dt">nrow=</span><span class="dv">3</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a>r[] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncell</span>(r)</span>
<span id="cb1-5"><a href="#cb1-5"></a>r</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#&gt; class      : RasterLayer </span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#&gt; dimensions : 3, 3, 9  (nrow, ncol, ncell)</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#&gt; resolution : 120, 60  (x, y)</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">#&gt; extent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">#&gt; crs        : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 </span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">#&gt; source     : memory</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">#&gt; names      : layer </span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">#&gt; values     : 1, 9  (min, max)</span></span></code></pre></div>
<p>The first line loads the package <strong>gdistance</strong>, which automatically loads the package <strong>raster</strong> as well. The second line creates a simple raster with 3 columns and 3 rows. The third line assigns the values 1 to 9 as the values of the cells. The resulting object is inspected in the fourth line. As can be seen in the output, the object does not only hold the cell values, but also holds metadata about the geographical properties of the raster.</p>
<p>It can also be seen that this is an object of the class <code>RasterLayer</code>. This class is for objects that hold only one layer of grid data. There are other classes which allow more than one layer of data: <code>RasterStack</code> and <code>RasterBrick</code>. Collectively, these classes are referred to as <code>Raster*</code>. A class is a static entity designed to represent objects of a certain type using ‘slots’, which each hold different information about the object. Both <strong>raster</strong> and <strong>gdistance</strong> use so-called S4 classes, a formal object-oriented system in <code>R</code>. An advantage of using classes is that data and metadata stay together and remain coherent. Consistent use of classes makes it more difficult to have contradictions in the information about an object. For example, changing the number of rows of a grid also has an effect on the total number of cells. Information about these two types of information of the same object could become contradictory if we were allowed to change one without adjusting the other. Classes make operations more rigid to avoid such contradictions. Operations that are geographically incorrect can also be detected in this way. For example, when the user tries to add the values of two rasters of different projections, the <strong>raster</strong> package will detect the difference and throw an error.</p>
<p>Classes also make it easier for the users to work with complex data and functions. Since so much information can be stored in a consistent way in objects and passed to functions, these functions need fewer options. Functions can deduce from the class of the object that is given to it, what it needs to do. The use of classes, if well done, tends to produce cleaner, more easily readable, and more consistent scripts. One important thing to know about <strong>raster</strong> is how grid data are stored internally in <code>Raster*</code> objects. Consecutive cell numbers in rasters go from left to right and from top to bottom. The 3 x 3 raster we just created with its cell numbers is shown in Figure 2.</p>
<div class="figure" style="text-align: center">
<img src="Overview_files/figure-html/figure1-1.png" alt="Fig. 2: Lon-lat grid with cell numbers of a 3 × 3 raster" width="700"><p class="caption">
Fig. 2: Lon-lat grid with cell numbers of a 3 × 3 raster
</p>
</div>
</div>
<div id="transition-classes" class="section level1">
<h1 class="hasAnchor">
<a href="#transition-classes" class="anchor"></a>Transition* classes</h1>
<p>As explained in Section 2 on the theory behind <strong>gdistance</strong>, transition matrices are the backbone of the package. The key classes in <strong>gdistance</strong> are <code>TransitionLayer</code> and <code>TransitionStack</code>. Most functions in the package have an object of one of these classes as input or output.</p>
<p><code>Transition*</code> objects can be constructed from an object of class <code>Raster*</code>. A <code>Transition*</code> object takes the necessary geographic references (projection, resolution, extent) from the original <code>Raster*</code> object. It also contains a matrix which represents a transition from one cell to another in the grid. Each row and column in the matrix represents a cell in the original <code>Raster*</code> object. Row 1 and column 1 in the transition matrix correspond to cell 1 in the original raster, row 2 and column 2 to cell 2, and so on. For example, the raster we just created would produce a 9 x 9 transition matrix with rows and columns numbered from 1 to 9 (see Figure 3 below).</p>
<p>The matrix is stored in a sparse format, as discussed in Section 2. The package <strong>gdistance</strong> makes use of sparse matrix classes and methods from the package <strong>Matrix</strong>, which gives access to fast procedures implemented in the <code>C</code> language <span class="citation">(Bates and Maechler 2017)</span>. The construction of a <code>Transition*</code> object from a <code>Raster*</code> object is straightforward. We can define an arbitrary function to calculate the conductance values from the values of each pair of cells to be connected.</p>
<p>In the following chunk of code, we use the <code>RasterLayer</code> that was created above. First, we set all its values to unit. The next line creates a <code>TransitionLayer</code>, setting the transition value between each pair of cells to the mean of the two cell values that are being connected. The <code>directions</code> argument is set to 8, which connects all cells to their 8 neighbours (Moore neighbourhood).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>r[] &lt;-<span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>tr1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/transition.html">transition</a></span>(r, <span class="dt">transitionFunction=</span>mean, <span class="dt">directions=</span><span class="dv">8</span>)</span></code></pre></div>
<p>If we inspect the object we created, we see that the resulting <code>TransitionLayer</code> object retains much information from the original <code>RasterLayer</code> object.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>tr1</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">#&gt; class      : TransitionLayer </span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">#&gt; dimensions : 3, 3, 9  (nrow, ncol, ncell)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">#&gt; resolution : 120, 60  (x, y)</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">#&gt; extent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">#&gt; crs        : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 </span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">#&gt; values      : conductance </span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co">#&gt; matrix class: dsCMatrix</span></span></code></pre></div>
<p>To illustrate how to create an asymmetric matrix, we first create a non-commutative distance function, <code>ncdf</code>. We then use this function as an argument in the function <code>transition</code>. To make sure that the resulting transition matrix is indeed asymmetric, we set the <code>symm</code> argument in <code>transition</code> to <code>FALSE</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>r[] &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="dv">9</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a>ncf &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(x) <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>x[<span class="dv">2</span>]</span>
<span id="cb4-3"><a href="#cb4-3"></a>tr2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/transition.html">transition</a></span>(r, ncf, <span class="dv">4</span>, <span class="dt">symm=</span><span class="ot">FALSE</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>tr2</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#&gt; class      : TransitionLayer </span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#&gt; dimensions : 3, 3, 9  (nrow, ncol, ncell)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">#&gt; resolution : 120, 60  (x, y)</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">#&gt; extent     : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">#&gt; crs        : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 </span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">#&gt; values      : conductance </span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">#&gt; matrix class: dgCMatrix</span></span></code></pre></div>
<p>Note the difference between <code>tr1</code> and <code>tr2</code> in the slot ‘matrix class’. This slot holds information about the matrix class as defined in the package <strong>Matrix</strong> <span class="citation">(Bates and Maechler 2017)</span>. The class <code>dsCMatrix</code> is for matrices that are symmetric. The class <code>dgCMatrix</code> holds an asymmetric matrix.</p>
<p>Different mathematical operations can be done with <code>Transition*</code> objects. This makes it possible to flexibly model different components of landscape friction.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>tr3 &lt;-<span class="st"> </span>tr1<span class="op">*</span>tr2</span>
<span id="cb5-2"><a href="#cb5-2"></a>tr3 &lt;-<span class="st"> </span>tr1<span class="op">+</span>tr2</span>
<span id="cb5-3"><a href="#cb5-3"></a>tr3 &lt;-<span class="st"> </span>tr1<span class="op">*</span><span class="dv">3</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>tr3 &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span>(tr1)</span></code></pre></div>
<p>Operations with more than one object require that the different objects have the same resolution and extent. Also, it is possible to extract and replace values in the matrix using indices, in a similar way to the use of indices with simple matrices.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>tr3[<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>)] &lt;-<span class="st"> </span>tr2[<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>)]</span>
<span id="cb6-2"><a href="#cb6-2"></a>tr3[<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>] &lt;-<span class="st"> </span>tr2[<span class="dv">1</span><span class="op">:</span><span class="dv">9</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">9</span>]</span>
<span id="cb6-3"><a href="#cb6-3"></a>tr3[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; 5 x 5 sparse Matrix of class "dgCMatrix"</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">#&gt;                                                       </span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#&gt; [1,] .         1.2890328 0.5303763 1.4784573 .        </span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">#&gt; [2,] 0.2875775 .         0.4089769 .         1.0926294</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">#&gt; [3,] 0.2875775 1.1676333 .         .         .        </span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">#&gt; [4,] 0.2875775 .         .         .         0.9979172</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co">#&gt; [5,] .         0.7883051 .         0.8830174 .</span></span></code></pre></div>
<p>The functions <code>adjacent</code> (from <strong>raster</strong>) and <code>adjacencyFromTransition</code> (from <strong>gdistance</strong>) can be used to create indices. Example 1 below illustrates this.</p>
<p>Some functions require that <code>Transition*</code> objects do not contain any isolated ‘clumps’, islands that are not connected to the rest of the raster cells. This can be avoided when creating <code>Transition*</code> objects, for instance by giving conductance values between all adjacent cells a small minimum value. It can be checked visually if there are any clumps. For the first method, the user can extract the transition matrix with function <code>transitionMatrix</code>. This gives a sparse matrix which can be vizualized with function <code>image</code>. This shows the rows and columns of the transition matrix and indicates which has a non-zero value, which represents a connection between cells (Figure 3).</p>
<div class="figure" style="text-align: center">
<img src="Overview_files/figure-html/gdistance-8-1.png" alt="Fig. 3: Visualizing a TransitionLayer with function image" width="700"><p class="caption">
Fig. 3: Visualizing a TransitionLayer with function image
</p>
</div>
<p>Figure 3 shows which cells are connected to each other. A close observer of Figure 3 may wonder why cell 1 is connected to 5 different cells, as this cell is located in the upper left corner of the original grid. This is explained by the extent of this particular grid. Since it covers the whole world, the outer meridians (180 and -180 degrees) touch each other. The software takes this into account and as a result the cells in the extreme left column are connected to the extreme right column. If the grid does not reach across the globe in longitudinal direction, this does not occur.</p>
<p>Figure 3 shows which cells contain non-zero values, but gives no further information about levels of conductance. The levels can be visualized by transforming the transition matrix back into a raster. To summarize the information in the transition matrix, we can take means or sums across rows or columns. Users can do this with function <code>raster</code>. For the different options see <code>method?raster("TransitionLayer")</code>. The default, shown in Figure 4, takes the column-wise means of the non-zero values.</p>
<div class="figure" style="text-align: center">
<img src="Overview_files/figure-html/figure3-1.png" alt="Fig. 4: Visualizing a TransitionLayer using the function raster. The result is a lon-lat grid with the same extent as the original RasterLayer." width="700"><p class="caption">
Fig. 4: Visualizing a TransitionLayer using the function raster. The result is a lon-lat grid with the same extent as the original RasterLayer.
</p>
</div>
</div>
<div id="correcting-transition-matrix-values" class="section level1">
<h1 class="hasAnchor">
<a href="#correcting-transition-matrix-values" class="anchor"></a>Correcting transition matrix values</h1>
<p>The function <code>transition</code> calculates transition values based on the values of adjacent cells in the input raster. However, diagonal neighbours are more remote from each other than orthogonal neighbours. Also, on equirectangular (longitude-latitude) grids, West-East connections are longer at the equator and become shorter towards the poles, as the meridians approach each other.</p>
<p>Therefore, the values in the matrix need to be corrected for these two types of distance distortion. Both types of distortion can be corrected by dividing each conductance matrix value by the distance between cell centres. This is what function <code>geoCorrection</code> does when <code>type</code> is set to “c”.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>tr1C &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr1, <span class="dt">type=</span><span class="st">"c"</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a>tr2C &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr2, <span class="dt">type=</span><span class="st">"c"</span>)</span></code></pre></div>
<p>However, as explained in Section 2 above, for commute distances (random walks) not only distance distortion plays a role, but also surface distortion. When <code>type</code> is set to “r” the function <code>geoCorrection</code> weights the probability of reaching an adjacent cell in a random walk by simply making it proportional to the surface covered by the cell. Computationally, the function corrects the surface distortion by multiplying the North-South transition values with the cosine of the average latitude of the two cell centres that are being connected.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>r3 &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="dt">ncol=</span><span class="dv">18</span>, <span class="dt">nrow=</span><span class="dv">9</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a>r3 &lt;-<span class="st"> </span><span class="kw">setValues</span>(r3, <span class="kw"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="dv">18</span><span class="op">*</span><span class="dv">9</span>)<span class="op">+</span><span class="dv">5</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a>tr3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/transition.html">transition</a></span>(r3, mean, <span class="dv">4</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a>tr3C &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr3, <span class="dt">type=</span><span class="st">"c"</span>, <span class="dt">multpl=</span><span class="ot">FALSE</span>, <span class="dt">scl=</span><span class="ot">TRUE</span>)</span>
<span id="cb8-5"><a href="#cb8-5"></a>tr3R &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr3, <span class="dt">type=</span><span class="st">"r"</span>, <span class="dt">multpl=</span><span class="ot">FALSE</span>, <span class="dt">scl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<p>The argument <code>scl</code> is set to <code>TRUE</code> to scale the transition values to a reasonable range. If the transition values are too large, commute distance and randomized shortest path functions will not work well. No scaling should be done if the user wants to obtain absolute distance values as output.</p>
<p>In some cases, <code>Transition*</code> objects with equal resolution and extent need to be corrected many times. For example, determining the optimal landscape friction weights using a genetic algorithm involves repeating the same calculations with many transition matrices that only differ in their values, but not in their resolution or extent <span class="citation">(van Etten and Hijmans 2010)</span>. In this case, computational effort can be reduced by preparing an object that only needs to be multiplied with the <code>Transition*</code> object to produce a corrected version of it.</p>
<p>The following chunk of code is equivalent to the previous one.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>CorrMatrix &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr3, <span class="dt">type=</span><span class="st">"r"</span>, <span class="dt">multpl=</span><span class="ot">TRUE</span>, <span class="dt">scl=</span><span class="ot">TRUE</span>)</span>
<span id="cb9-2"><a href="#cb9-2"></a>tr3R &lt;-<span class="st"> </span>tr3 <span class="op">*</span><span class="st"> </span>CorrMatrix</span></code></pre></div>
<p>Object <code>CorrMatrix</code> is only calculated once. It can be multiplied with <code>Transition*</code> objects, as long as they have the same extent, resolution, and directions of cell connections. We need to take special care that the geo-correction multiplication matrix (<code>CorrMatrix</code>) contains all non-zero values that are present in the <code>Transition*</code> object with which it will be multiplied (<code>tr3</code> in this case).</p>
</div>
<div id="calculating-distances" class="section level1">
<h1 class="hasAnchor">
<a href="#calculating-distances" class="anchor"></a>Calculating distances</h1>
<p>After obtaining the geographically corrected <code>Transition*</code> object, we can calculate distances between points. It is important to note that all distance functions require a <code>Transition*</code> object with conductance values, even though distances will be expressed in 1/conductance (friction or resistance) units (see Section 2 above).</p>
<p>To calculate distances, we need to have the coordinates of point locations. This is done by creating a two-column matrix of coordinates. Functions will also accept a <code>SpatialPoints</code> object or, if there is only one point, a vector of length two.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>sP &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="op">-</span><span class="dv">100</span>, <span class="dv">-100</span>, <span class="dv">100</span>), <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">50</span>, <span class="dv">-50</span>, <span class="dv">50</span>))</span></code></pre></div>
<p>Calculating a distance matrix is straightforward now.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw"><a href="../reference/costDistance-methods.html">costDistance</a></span>(tr3C, sP)</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co">#&gt;           1         2</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co">#&gt; 2 0.8842550          </span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co">#&gt; 3 0.9508077 1.5139996</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw"><a href="../reference/commuteDistance-methods.html">commuteDistance</a></span>(tr3R, sP)</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">#&gt;           1         2</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co">#&gt; 2  998.0584          </span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="co">#&gt; 3  980.4971 1085.3238</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="kw"><a href="../reference/rSPDistance.html">rSPDistance</a></span>(tr3R, sP, sP, <span class="dt">theta=</span><span class="fl">1e-12</span>, <span class="dt">totalNet=</span><span class="st">"total"</span>)</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="co">#&gt;          [,1]     [,2]     [,3]</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co">#&gt; [1,]  0.00000 57.91140 56.75376</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="co">#&gt; [2,] 56.62602  0.00000 62.12604</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="co">#&gt; [3,] 55.76832 62.42598  0.00000</span></span></code></pre></div>
<p>The <code>costDistance</code> function relies on the package <strong>igraph</strong> <span class="citation">(Csardi and Nepusz 2006)</span> for the underlying calculation. It gives a symmetric or asymmetric distance matrix, depending on the <code>TransitionLayer</code> that is used as input.</p>
<p>Commute distance is the number of cells traversed during a random walk from a cell <span class="math inline">\(i\)</span> on the grid to a cell <span class="math inline">\(j\)</span> and back to <span class="math inline">\(i\)</span> <span class="citation">(Chandra et al. 1996)</span>.</p>
<p><code>rSPDistance</code> gives the cost incurred during the same walk (<span class="math inline">\(\theta\)</span> approaches zero, so this is the cost incurred during a random walk, see Section 2). To obtain the commute costs we sum the corresponding off-diagonal elements: <span class="math inline">\(d_{ij} + d_{ji}\)</span>. This is the distance of a commute from <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> and back from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span>.</p>
<p>In this case, the commute costs (resistance) are close to the commute distances (number of steps). This is because the <code>TransitionLayer</code> object has been scaled, so that transition costs are close to unit for each step and the total number of steps and the total distance are of the same order of magnitude.</p>
</div>
<div id="dispersal-paths" class="section level1">
<h1 class="hasAnchor">
<a href="#dispersal-paths" class="anchor"></a>Dispersal paths</h1>
<p>To determine dispersal paths of a (constrained) random walk, we use the function <code>passage</code>. This function can be used for both random walks and randomised shortest paths. The function calculates the average number of passages through cells or connections between cells before arriving in the destination cell. Either the total or net number of passages can be calculated. The net number of passages is the number of passages that are not reciprocated by a passage in the opposite direction. In other words, this is the probability of the “last forward” passage going through a cell-to-cell connection <span class="citation">(McRae et al. 2008)</span>.</p>
<p>Figure 5 shows the net passages through each cell, assuming randomised shortest paths with the parameter <span class="math inline">\(\theta\)</span> set to 3.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>origin &lt;-<span class="st"> </span><span class="kw">SpatialPoints</span>(<span class="kw"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span>(<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb12-2"><a href="#cb12-2"></a>rSPraster &lt;-<span class="st"> </span><span class="kw"><a href="../reference/passage.html">passage</a></span>(tr3C, origin, sP[<span class="dv">1</span>,], <span class="dt">theta=</span><span class="dv">3</span>)</span></code></pre></div>
<div class="figure">
<img src="Overview_files/figure-html/figure4-1.png" alt="Fig. 5. Net passages from origin O to destination sP1." width="700"><p class="caption">
Fig. 5. Net passages from origin O to destination sP1.
</p>
</div>
</div>
<div id="path-overlap-and-non-overlap" class="section level1">
<h1 class="hasAnchor">
<a href="#path-overlap-and-non-overlap" class="anchor"></a>Path overlap and non-overlap</h1>
<p>One of the specific uses for which package gdistance was created, is to look at dispersal trajectories of organisms that expand their range coming from a single source <span class="citation">(van Etten and Hijmans 2010)</span>. The degree of coincidence of two trajectories can be determined by calculating the minimum of the net passages of the two trajectories. With a formula presented in <span class="citation">(van Etten and Hijmans 2010)</span>, we can approximate the non-overlapping part of the trajectory. This is done in the following code.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>r1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/passage.html">passage</a></span>(tr3C, origin, sP[<span class="dv">1</span>,], <span class="dt">theta=</span><span class="dv">1</span>)</span>
<span id="cb13-2"><a href="#cb13-2"></a>r2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/passage.html">passage</a></span>(tr3C, origin, sP[<span class="dv">2</span>,], <span class="dt">theta=</span><span class="dv">1</span>)</span>
<span id="cb13-3"><a href="#cb13-3"></a>rJoint &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span>(r1, r2)</span>
<span id="cb13-4"><a href="#cb13-4"></a>rDiv &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span>(r1, r2) <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span>(r1, r2)) <span class="op">-</span><span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span>(r1, r2), <span class="dv">0</span>) </span></code></pre></div>
<p>The first two lines create two different trajectories, both coming from the same point of origin (O) and going to different end destinations (referred to as sP1 and sP2 in the following). The third line obtains the minimum probability as a measure of the overlap between the two trajectories. The resulting raster <code>rJoint</code> is visualized in Figure 6. The fourth line calculates the non-overlapping part of the trajectories with a more complicated formula. The result, <code>rDiv</code>, is shown in Figure 7.</p>
<div class="figure">
<img src="Overview_files/figure-html/figure5-1.png" alt="Fig. 6. Overlapping part of the two routes from origin O to sP1 and sP2 respectively." width="700"><p class="caption">
Fig. 6. Overlapping part of the two routes from origin O to sP1 and sP2 respectively.
</p>
</div>
<div class="figure">
<img src="Overview_files/figure-html/figure6-1.png" alt="Fig. 7. Non-overlapping part of the two routes from origin O to sP1 and sP2 respectively." width="700"><p class="caption">
Fig. 7. Non-overlapping part of the two routes from origin O to sP1 and sP2 respectively.
</p>
</div>
<p>With the function <code>pathInc</code> we can calculate measures of path overlap and non-overlap for a large number of points. These measures can be used to predict patterns of diversity if these are due to dispersal from a single common source. If the argument <code>type</code> contains two or more elements, the result is a list of distances matrices. The default for <code>type</code> is to calculate joint and divergent length of the dispersal paths.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw"><a href="../reference/pathInc.html">pathInc</a></span>(tr3C, origin, sP)</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">#&gt; $function1layer1</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">#&gt;          1        2</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="co">#&gt; 2 2.363770         </span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="co">#&gt; 3 2.318019 2.100372</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="co">#&gt; </span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="co">#&gt; $function2layer1</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="co">#&gt;          1        2</span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">#&gt; 2 2.255957         </span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co">#&gt; 3 2.397766 2.802147</span></span></code></pre></div>
</div>
<div id="example-1-hiking-around-maunga-whau" class="section level1">
<h1 class="hasAnchor">
<a href="#example-1-hiking-around-maunga-whau" class="anchor"></a>Example 1: Hiking around Maunga Whau</h1>
<p>The previous examples were theoretical, based on randomly generated values. More realistic examples serve to illustrate the various uses that can be given to this package.</p>
<p>Determining the fastest route between two points in complex terrain is useful for hikers. Tobler’s Hiking Function provides a rough estimate of the maximum hiking speed (<span class="math inline">\(s\)</span>) given the slope of the terrain (<span class="math inline">\(m\)</span>) <span class="citation">(Tobler 1993)</span>. The maximum speed of off-path hiking (in m/s) is:</p>
<p><span class="math display">\[ s = 6 e^{-3.5 |m + 0.05|} \]</span></p>
<p>Note that the function is not symmetric around 0 (see Figure 8). Hikers walk fastest on gently downward slopes (<span class="math inline">\(m = -0.05\)</span>), where they can walk faster than on flat terrain (<span class="math inline">\(m = 0\)</span>).</p>
<div class="figure">
<img src="Overview_files/figure-html/figure7-1.png" alt="Fig. 8. Tobler's Hiking Function." width="700"><p class="caption">
Fig. 8. Tobler’s Hiking Function.
</p>
</div>
<p>We use the Hiking Function to determine the shortest path to hike around the volcano Maunga Whau (Auckland, New Zealand). First, we read in the altitude data for the volcano. This is the <code>R</code> base dataset (see <code><a href="https://rdrr.io/r/datasets/volcano.html">?volcano</a></code>), which has been geo-referenced using the information provided by T. Hengl at .</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a>r &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="kw"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span>(<span class="st">"external/maungawhau.grd"</span>, <span class="dt">package=</span><span class="st">"gdistance"</span>))</span></code></pre></div>
<p>The Hiking Function requires the slope (<span class="math inline">\(m\)</span>) as input, which can be calculated from the altitude (<span class="math inline">\(z\)</span>) and distance between cell centres (<span class="math inline">\(d\)</span>).</p>
<p><span class="math display">\[ m_{ij} = (z_j - z_i) / d_{ij} \]</span></p>
<p>The units of altitude and distance should be identical. Here, we use meters for both. First, we calculate the altitudinal differences between cells. Then we use the <code>geoCorrection</code> function to divide by the distance between cells.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>altDiff &lt;-<span class="st"> </span><span class="cf">function</span>(x){x[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>x[<span class="dv">1</span>]}</span>
<span id="cb16-2"><a href="#cb16-2"></a>hd &lt;-<span class="st"> </span><span class="kw"><a href="../reference/transition.html">transition</a></span>(r, altDiff, <span class="dv">8</span>, <span class="dt">symm=</span><span class="ot">FALSE</span>)</span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">#&gt; Warning in .TfromR(x, transitionFunction, directions, symm): transition function</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">#&gt; gives negative values</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>slope &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(hd)</span></code></pre></div>
<p>The <code>transition</code> function throws a warning, because a matrix with negative values cannot be used directly in distance calculations. Here this warning can be safely ignored, however, as the negative values are only present in intermediate steps. Subsequently, we calculate the speed. We need to exercise special care, because the matrix values between non-adjacent cells is 0, but the slope between these cells is not 0! Therefore, we need to restrict the calculation to adjacent cells. We do this by creating an index for adjacent cells (<code>adj</code>) with the function <code>adjacent</code>.</p>
<p>Using this index, we extract and replace adjacent cells, without touching the other values.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a>adj &lt;-<span class="st"> </span><span class="kw">adjacent</span>(r, <span class="dt">cells=</span><span class="dv">1</span><span class="op">:</span><span class="kw">ncell</span>(r), <span class="dt">pairs=</span><span class="ot">TRUE</span>, <span class="dt">directions=</span><span class="dv">8</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>speed &lt;-<span class="st"> </span>slope</span>
<span id="cb18-3"><a href="#cb18-3"></a>speed[adj] &lt;-<span class="st"> </span><span class="dv">6</span> <span class="op">*</span><span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/Log.html">exp</a></span>(<span class="op">-</span><span class="fl">3.5</span> <span class="op">*</span><span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span>(slope[adj] <span class="op">+</span><span class="st"> </span><span class="fl">0.05</span>))</span></code></pre></div>
<p>Now we have calculated the speed of movement between adjacent cells. We are close to having the final conductance values. Attainable speed is a measure of the ease of crossing from one cell to another on the grid. However, we also need to take into account the distance between cell centres. Travelling with the same speed, a diagonal connection between cells takes longer to cross than a straight connection. Therefore, we use the function <code>geoCorrection</code> again.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>Conductance &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(speed) </span></code></pre></div>
<p>This gives our final ‘conductance’ values. What do these values mean? The function <code>geoCorrection</code> divides the values in the matrix between the distance between cell centres. So, with our last command we calculated conductance (<span class="math inline">\(C\)</span>) as follows:</p>
<p><span class="math display">\[ C = s / d \]</span></p>
<p>This looks a lot like a measure that we are more familiar with, travel time (<span class="math inline">\(t\)</span>):</p>
<p><span class="math display">\[ t = d / s \]</span></p>
<p>In fact, the conductance values we have calculated are the reciprocal of travel time (<span class="math inline">\(1/t\)</span>).</p>
<p><span class="math display">\[ 1 / t = s / d = C \]</span></p>
<p>Maximizing the reciprocal of travel time is exactly equivalent to minimizing travel time. Distances calculated with this conductance matrix represent travel time according to the Hiking Function.</p>
<p>In the next step, we define two coordinates, A and B, and determine the paths between them. We test if the quickest path from A to B is the same as the quickest path from B back to A. The following code creates the shortest paths.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>A &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">2667670</span>, <span class="dv">6479000</span>)</span>
<span id="cb20-2"><a href="#cb20-2"></a>B &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="dv">2667800</span>, <span class="dv">6479400</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a>AtoB &lt;-<span class="st"> </span><span class="kw"><a href="../reference/shortestPath.html">shortestPath</a></span>(Conductance, A, B, <span class="dt">output=</span><span class="st">"SpatialLines"</span>)</span>
<span id="cb20-4"><a href="#cb20-4"></a>BtoA &lt;-<span class="st"> </span><span class="kw"><a href="../reference/shortestPath.html">shortestPath</a></span>(Conductance, B, A, <span class="dt">output=</span><span class="st">"SpatialLines"</span>)</span></code></pre></div>
<p>And this code reproduces Figure 9.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw"><a href="https://rdrr.io/r/graphics/plot.html">plot</a></span>(r, <span class="dt">xlab=</span><span class="st">"x coordinate (m)"</span>, <span class="dt">ylab=</span><span class="st">"y coordinate (m)"</span>,</span>
<span id="cb21-2"><a href="#cb21-2"></a>     <span class="dt">legend.lab=</span><span class="st">"Altitude (masl)"</span>)</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span>(AtoB, <span class="dt">col=</span><span class="st">"red"</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span>(BtoA, <span class="dt">col=</span><span class="st">"blue"</span>)</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="kw"><a href="https://rdrr.io/r/graphics/text.html">text</a></span>(A[<span class="dv">1</span>] <span class="op">-</span><span class="st"> </span><span class="dv">10</span>, A[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span><span class="dv">10</span>, <span class="st">"A"</span>)</span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw"><a href="https://rdrr.io/r/graphics/text.html">text</a></span>(B[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span><span class="dv">10</span>, B[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span><span class="dv">10</span>, <span class="st">"B"</span>)</span></code></pre></div>
<p>A small part of the A-B (red) and B-A (blue) lines in Figure 9 do not overlap. This is a consequence of the asymmetry of the Hiking Function.</p>
<div class="figure">
<img src="Overview_files/figure-html/fig8-1.png" alt="Fig. 9. Quickest hiking routes on Maunga Whau between A and B (A to B is red, B to A is blue). (Coordinate system is the New Zealand Map Grid.)" width="700"><p class="caption">
Fig. 9. Quickest hiking routes on Maunga Whau between A and B (A to B is red, B to A is blue). (Coordinate system is the New Zealand Map Grid.)
</p>
</div>
</div>
<div id="example-2-geographical-genetics" class="section level1">
<h1 class="hasAnchor">
<a href="#example-2-geographical-genetics" class="anchor"></a>Example 2: Geographical genetics</h1>
<p>A correlation between genetic differentiation and geographic distance of individuals and populations is expected due to a mechanism known as isolation by distance <span class="citation">(Wright 1943)</span>. This correlation is expected when random, symmetric dispersal occurs in homogeneous geographic spaces. For random dispersal in heterogeneous landscapes, recent work has shown that genetic differentiation correlates with the resistance distance between their locations <span class="citation">(McRae 2006)</span>. In this section, we look at human genetic diversity in Europe, using the data presented by <span class="citation">(Balaresque et al. 2010)</span>.</p>
<p>First, we read in the data: a map of Europe, the coordinates of the populations (see Figure 10) and mutual genetic distances (see <code><a href="../reference/genDist.html">?genDist</a></code> for more information on these data).</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>Europe &lt;-<span class="st"> </span><span class="kw">raster</span>(<span class="kw"><a href="https://rdrr.io/r/base/system.file.html">system.file</a></span>(<span class="st">"external/Europe.grd"</span>, </span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="dt">package=</span><span class="st">"gdistance"</span>))</span>
<span id="cb22-3"><a href="#cb22-3"></a>Europe[<span class="kw"><a href="https://rdrr.io/r/base/NA.html">is.na</a></span>(Europe)] &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="kw"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(genDist)</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="kw"><a href="https://rdrr.io/r/utils/data.html">data</a></span>(popCoord)</span>
<span id="cb22-6"><a href="#cb22-6"></a>pC &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">as.matrix</a></span>(popCoord[<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"x"</span>,<span class="st">"y"</span>)])</span></code></pre></div>
<div class="figure">
<img src="Overview_files/figure-html/fig10-1.png" alt="Fig. 10. Map of genotyped populations." width="700"><p class="caption">
Fig. 10. Map of genotyped populations.
</p>
</div>
<p>Then we create three geographical distance matrices. The first corresponds to the great-circle distance between populations. The second is the least-cost distance between locations. Travel is restricted to the land mass. The third is the commute distance (using the same conductance matrix), which is related to effective resistance between points if we conceive of the grid as an electrical circuit <span class="citation">(Chandra et al. 1996; McRae 2006)</span>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a>geoDist &lt;-<span class="st"> </span><span class="kw">pointDistance</span>(pC, <span class="dt">longlat=</span><span class="ot">TRUE</span>)</span>
<span id="cb23-2"><a href="#cb23-2"></a>geoDist &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/stats/dist.html">as.dist</a></span>(geoDist)</span>
<span id="cb23-3"><a href="#cb23-3"></a>Europe &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/stats/aggregate.html">aggregate</a></span>(Europe,<span class="dv">3</span>)</span>
<span id="cb23-4"><a href="#cb23-4"></a>tr &lt;-<span class="st"> </span><span class="kw"><a href="../reference/transition.html">transition</a></span>(Europe, mean, <span class="dt">directions=</span><span class="dv">8</span>)</span>
<span id="cb23-5"><a href="#cb23-5"></a>trC &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr, <span class="st">"c"</span>, <span class="dt">scl=</span><span class="ot">TRUE</span>)</span>
<span id="cb23-6"><a href="#cb23-6"></a>trR &lt;-<span class="st"> </span><span class="kw"><a href="../reference/geoCorrection.html">geoCorrection</a></span>(tr, <span class="st">"r"</span>, <span class="dt">scl=</span><span class="ot">TRUE</span>)</span>
<span id="cb23-7"><a href="#cb23-7"></a>cosDist &lt;-<span class="st"> </span><span class="kw"><a href="../reference/costDistance-methods.html">costDistance</a></span>(trC,pC)</span>
<span id="cb23-8"><a href="#cb23-8"></a>resDist &lt;-<span class="st"> </span><span class="kw"><a href="../reference/commuteDistance-methods.html">commuteDistance</a></span>(trR, pC)</span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span>(genDist,geoDist)</span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="co">#&gt; [1] 0.5964302</span></span>
<span id="cb23-11"><a href="#cb23-11"></a><span class="kw"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span>(genDist,cosDist)</span>
<span id="cb23-12"><a href="#cb23-12"></a><span class="co">#&gt; [1] 0.588961</span></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="kw"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span>(genDist,resDist)</span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="co">#&gt; [1] 0.1917362</span></span></code></pre></div>
<p>Among the distance measures evaluated until now, the great-circle distance between points turns out to be the best predictor of genetic distance. The other distance measures incorporate more information about the geographic space in which geneflow takes place, but do not improve the prediction. It follows that prehistoric people in Europe did not move like wolves (least-cost distance) or drunkards (commute or resistance distance), but rather like crows (great-circle distance).</p>
<p>An important assumption behind these distance measures, however, is that dispersal is symmetric. This is often not the case. For example, diffusion from a single origin (Africa) explains much of the current geographical patterns of human genetic diversity <span class="citation">(Ramachandran et al. 2005)</span>. As a result, the mutual genetic distance between a pair of humans from different parts from the globe depends on the extent they share their prehistoric migration history. Within Europe, genetic diversity is often thought to be a result of the migration of early Neolithic farmers from Anatolia (now part of modern Turkey) to the west.</p>
<p>How well does a geographic wave of expansion from Anatolia explain the spatial pattern? The function <code>pathInc</code> calculates the overlap (and non-overlap) of dispersal paths from a common origin on the grid as a distance measure between points.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a>origin &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span>(popCoord[<span class="dv">22</span>,<span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"x"</span>,<span class="st">"y"</span>)])</span>
<span id="cb24-2"><a href="#cb24-2"></a>pI &lt;-<span class="st"> </span><span class="kw"><a href="../reference/pathInc.html">pathInc</a></span>(trC, <span class="dt">origin=</span>origin, <span class="dt">from=</span>pC, </span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="dt">functions=</span><span class="kw"><a href="https://rdrr.io/r/base/list.html">list</a></span>(overlap))</span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw"><a href="https://rdrr.io/r/stats/cor.html">cor</a></span>(genDist,pI[[<span class="dv">1</span>]])</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="co">#&gt; [1] -0.7178411</span></span></code></pre></div>
<p>At least at first sight, the overlap of dispersal routes explains the spatial pattern better than any of the previous measures. The negative sign of the last correlation coefficient was expected, as more overlap in routes is associated with lower genetic distance. Additional work would be needed to improve predictions and compare the different models more rigorously.</p>
</div>
<div id="future-work" class="section level1">
<h1 class="hasAnchor">
<a href="#future-work" class="anchor"></a>Future work</h1>
<p>Improvements of <strong>gdistance</strong> and methodological refinements are expected in various areas. * All measures based on random walks depend critically on solving sparse linear systems. This is the most time-consuming part of the calculations. Faster libraries could improve the <strong>gdistance</strong> package if they become available in <code>R</code> in the future. * Research on distances in graph theory is a very dynamic field in the computational sciences. New measures and algorithms could be added to <strong>gdistance</strong> when they become available. * More research on the consequences of connecting grids in different ways is necessary, as indicated in Section 2. This should bring more precision to random walk calculations in geospatial analysis. Comparing the results of grid-based calculations to continuous space simulations or analytical solutions would be the way forward <span class="citation">(Birch 2006)</span>.</p>
</div>
<div id="acknowledgements" class="section level1">
<h1 class="hasAnchor">
<a href="#acknowledgements" class="anchor"></a>Acknowledgements</h1>
<p>This research is supported by CGIAR Fund Donors. Work on the <strong>gdistance</strong> package started during the project “Collective Action for the Rehabilitation of Global Public Goods in the CGIAR Genetic Resources System: Phase 2” (2007-2010), under the guidance of Dr Robert Hijmans. Finalizing the package was undertaken as part of the CGIAR Research Program on Climate Change, Agriculture and Food Security (CCAFS), which is a strategic partnership of CGIAR and Future Earth. The views expressed in this document cannot be taken to reflect the official opinions of CGIAR or Future Earth.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references hanging-indent">
<div id="ref-bal2010">
<p>Balaresque, P., G. R. Bowden, S. M. Adams, H.-Y. Leung, T. E. King, Z. H. Rosser, J. Goodwin, et al. 2010. “A Predominantly Neolithic Origin for European Paternal Lineages.” <em>PLoS Biology</em> 8 (1): e1000285. <a href="https://doi.org/10.1371/journal.pbio.1000285">https://doi.org/10.1371/journal.pbio.1000285</a>.</p>
</div>
<div id="ref-maechler2012">
<p>Bates, Douglas, and Martin Maechler. 2017. <em>Matrix: Sparse and Dense Matrix Classes and Methods</em>. <a href="https://CRAN.R-project.org/package=Matrix">https://CRAN.R-project.org/package=Matrix</a>.</p>
</div>
<div id="ref-birch2006">
<p>Birch, C. P. D. 2006. “Diagonal and Orthogonal Neighbours in Grid-Based Simulations: Buffon’s Stick After 200 Years.” <em>Ecological Modelling</em> 192 (3–4): 637–44. <a href="https://doi.org/10.1016/j.ecolmodel.2005.07.017">https://doi.org/10.1016/j.ecolmodel.2005.07.017</a>.</p>
</div>
<div id="ref-chandra1996">
<p>Chandra, A. K., P. Raghavan, W. L Ruzzo, R. Smolensky, and P. Tiwari. 1996. “The Electrical Resistance of a Graph Captures Its Commute and Cover Times.” <em>Computational Complexity</em> 6 (4): 312–40. <a href="https://doi.org/10.1007/BF01270385">https://doi.org/10.1007/BF01270385</a>.</p>
</div>
<div id="ref-csardi2006">
<p>Csardi, Gabor, and Tamas Nepusz. 2006. “The Igraph Software Package for Complex Network Research.” <em>InterJournal</em>, 1695.</p>
</div>
<div id="ref-deSmith2009">
<p>de Smith, M. J., M. F. Goodchild, and P. A. Longley. 2009. <em>Geospatial Analysis</em>. Matador.</p>
</div>
<div id="ref-grass">
<p> Development Team. 2017. <em>Geographic Resources Analysis Support System (GRASS Gis) Software</em>. USA: Open Source Geospatial Foundation. <a href="http://grass.osgeo.org/">http://grass.osgeo.org/</a>.</p>
</div>
<div id="ref-dijkstra1959">
<p>Dijkstra, E. W. 1959. “A Note on Two Problems in Connexion with Graphs.” <em>Numerische Mathematik</em> 1 (1): 269–71. <a href="https://doi.org/10.1007/bf01386390">https://doi.org/10.1007/bf01386390</a>.</p>
</div>
<div id="ref-doyle1984">
<p>Doyle, P. G, and J. L. Snell. 1984. <em>Random Walks and Electric Networks</em>. Carus Mathematical Monographs 22. Mathematical Association of America.</p>
</div>
<div id="ref-fouss2007">
<p>Fouss, Francois, Alain Pirotte, Jean-Michel Renders, and Marco Saerens. 2007. “Random-Walk Computation of Similarities Between Nodes of a Graph with Application to Collaborative Recommendation.” <em>IEEE Transactions on Knowledge and Data Engineering</em> 19 (3): 355–69. <a href="https://doi.org/10.1109/tkde.2007.46">https://doi.org/10.1109/tkde.2007.46</a>.</p>
</div>
<div id="ref-hijmans2012">
<p>Hijmans, Robert J., and Jacob van Etten. 2016. <em>Raster: Geographic Data Analysis and Modeling</em>. <a href="https://CRAN.R-project.org/package=raster">https://CRAN.R-project.org/package=raster</a>.</p>
</div>
<div id="ref-kivimaki2012">
<p>Kivimäki, I., M. Shimbo, and M. Saerens. 2014. “Developments in the Theory of Randomized Shortest Paths with a Comparison of Graph Node Distances.” <em>Physica A: Statistical Mechanics and Its Applications</em> 393: 600–616. <a href="https://doi.org/10.1016/j.physa.2013.09.016">https://doi.org/10.1016/j.physa.2013.09.016</a>.</p>
</div>
<div id="ref-mccoy2002">
<p>McCoy, J., and K. Johnston. 2002. <em>Using ArcGIS Spatial Analyst</em>. ESRI Press.</p>
</div>
<div id="ref-mcrae2006">
<p>McRae, B. H. 2006. “Isolation by Resistance.” <em>Evolution</em> 60 (8): 1551–61. <a href="https://doi.org/10.1111/j.0014-3820.2006.tb00500.x">https://doi.org/10.1111/j.0014-3820.2006.tb00500.x</a>.</p>
</div>
<div id="ref-mcrae2008">
<p>McRae, B. H., B. G. Dickson, T. H. Keitt, and V. B. Shah. 2008. “Using Circuit Theory to Model Connectivity in Ecology, Evolution, and Conservation.” <em>Ecological Modelling</em> 89 (10): 2712–24. <a href="https://doi.org/10.1890/07-1861.1">https://doi.org/10.1890/07-1861.1</a>.</p>
</div>
<div id="ref-ram2005">
<p>Ramachandran, S., O. Deshpande, C. C. Roseman, N. A. Rosenberg, M. W. Feldman, and L. L. Cavalli-Sforza. 2005. “Support from the Relationship of Genetic and Geographic Distance in Human Populations for a Serial Founder Effect Originating in Africa.” <em>Proceedings of the National Academy of Science of the United States of America</em> 102 (44): 15942–7. <a href="https://doi.org/10.1073/pnas.0507611102">https://doi.org/10.1073/pnas.0507611102</a>.</p>
</div>
<div id="ref-R2014">
<p>R Core Team. 2016. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="https://www.R-project.org/">https://www.R-project.org/</a>.</p>
</div>
<div id="ref-saerens2009">
<p>Saerens, M., L. Yen, F. Fouss, and Y. Achbany. 2009. “Randomized Shortest-Path Problems: Two Related Models.” <em>Neural Computation</em> 21 (8): 2363–2404. <a href="https://doi.org/10.1162/neco.2009.11-07-643">https://doi.org/10.1162/neco.2009.11-07-643</a>.</p>
</div>
<div id="ref-tobler1970">
<p>Tobler, W. 1970. “A Computer Movie Simulating Urban Growth in the Detroit Region.” <em>Economic Geography</em> 46 (2): 234–40. <a href="https://doi.org/10.2307/143141">https://doi.org/10.2307/143141</a>.</p>
</div>
<div id="ref-tobler1993">
<p>———. 1993. “Three Presentations on Geographical Analysis and Modeling.” 93-1. National Center for Geographic Information; Analysis. <a href="http://www.ncgia.ucsb.edu/Publications/Tech%5C_Reports/93/93-1.PDF">http://www.ncgia.ucsb.edu/Publications/Tech\_Reports/93/93-1.PDF</a>.</p>
</div>
<div id="ref-etten2017">
<p>van Etten, Jacob. 2017. “R Package gdistance: Distances and Routes on Geographical Grids.” <em>Journal of Statistical Software</em> 76 (13): 1–21. <a href="https://doi.org/10.18637/jss.v076.i13">https://doi.org/10.18637/jss.v076.i13</a>.</p>
</div>
<div id="ref-etten2010">
<p>van Etten, J., and R. J. Hijmans. 2010. “A Geospatial Modelling Approach Integrating Archaeobotany and Genetics to Trace the Origin and Dispersal of Domesticated Plants.” <em>PLoS ONE</em> 5 (8): e12060. <a href="https://doi.org/10.1371/journal.pone.0012060">https://doi.org/10.1371/journal.pone.0012060</a>.</p>
</div>
<div id="ref-wright1943">
<p>Wright, S. 1943. “Isolation by Distance.” <em>Genetics</em> 28 (2): 114–38. <a href="https://doi.org/10.1038/hdy.2014.62">https://doi.org/10.1038/hdy.2014.62</a>.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#summary">Summary</a></li>
      <li><a href="#introduction-the-crow-the-wolf-and-the-drunkard">Introduction: the crow, the wolf, and the drunkard</a></li>
      <li><a href="#theory">Theory</a></li>
      <li><a href="#raster-basics">Raster basics</a></li>
      <li><a href="#transition-classes">Transition* classes</a></li>
      <li><a href="#correcting-transition-matrix-values">Correcting transition matrix values</a></li>
      <li><a href="#calculating-distances">Calculating distances</a></li>
      <li><a href="#dispersal-paths">Dispersal paths</a></li>
      <li><a href="#path-overlap-and-non-overlap">Path overlap and non-overlap</a></li>
      <li><a href="#example-1-hiking-around-maunga-whau">Example 1: Hiking around Maunga Whau</a></li>
      <li><a href="#example-2-geographical-genetics">Example 2: Geographical genetics</a></li>
      <li><a href="#future-work">Future work</a></li>
      <li><a href="#acknowledgements">Acknowledgements</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Jacob van Etten, Kaue de Sousa.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
